---
layout: page
title:  Citations
permalink: /citation/
---

* Retrospection is more rewarding when we reflect on the articulation of the problem as well as the adequacy of the solution.

* Don't wait for a better situation to refactor. Just put your current understanding into the current situation. It is a journey of learning, not a destination.

* Emergence is the consequence of learning.

* An object is defined by its behaviour.
  Thus, inside a netwrok of interacting objects, each object is defined in terms of the its behavioural contribution to the system.
  The structure of an object system then follows the distribution of behaviour between its constituents.

* Set a direction or a destination before refactoring. Or just discover it as you go.

* A refactoring should either contribute to a purpose or help us understand the code. Before refactoring, set a direction or a target situation/condition.

* TDD is a continuous conversation with the situation where we favour exploring the problem over imposing our the synthesis of old solutions.

* After reflecting and finding the decision that led to a wrong move, atomic check-ins are great to recover the last stable state of the code.

* With each novelity, find the right symetry with what you already now, so that you don't mistake the difference(and miss the opportunity) and fully embrace the new way of working. (espically at dealing with the new problems in the old way using the new tools); eg. c and c++ are all about coding, but how to code is the symetry?

* Restating the problem challenges implicit premises and opens new perspectives towards unknown aspects.

* I the idea of 'exploring the problem' resonates with me more than 'solving the problem', maybe the problem is an early view of the solution, maybe the we are sensing/articulating/shaping the problem as we go.

* We learn better by discovery, not instruction, thus, design is the outcome of our continuous discovery and learning experience. Feedback and reflection enlighten our journey. Design reflects our understanding.

* It's more about committing to flexibility axis than it is about committing to the decision itself. In some contexts(where axis/scales of change are predictable; user requirements), simple design could be a good strategy/an enabler for a fluid change, in other cases, where refactoring is costly, that would be more of a roadblock. Isolation boundaries are critical, indeed, they do minifies the cost of change on the whole system.

* The dichotomy between BUD and ED is measured against adheration to forces (that could be opposite) exerced by the environment on the system, i.e: customer, techonology, business rules, team skills, ... Then, The cost of changing the tension of each force highlights architectural decisions (axis of change).

* If the only adequate name of a variable is the name of its type(class), reconcider the design, the level of abstractions, and the substance of your abstractions.
