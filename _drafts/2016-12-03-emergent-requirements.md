---
layout: post
comments: true
title:  "Emergent requirements"
date:   2016-12-03 22:27:43 +0100
categories: Software
tags: featured
---

As a learning activity, product development involves the articulation of a set
of problems and the hunt of a good-enough way to solve them.
Each requirement is supposed to solve a tiny problem,
and the collection of tiny solutions solves a huge problem.
Each user uses the product because it solves their problems in a way that fits
well within its context.
Both the context and the problems are unknowns initially.
Identifying them, thus, is in itself a complex activity 
that it requires learning and reflection.

*Failing as a pivot better decisions*

The whole solution is more than the sum of the requirements.
It is also, how these work together and how they perform in the context of the user.

Figuring out the requirements before starting the development is based on a set
of assumptions:
 - Each requirement solve a problem the user have.
 - The articulated problem is really a problem the user is struggling with.
 - The requirements, as a whole, improve the life of the user and create less frustration.
 - The requirements form a cohesive whole.
 - The whole team, as well as the user, 
   share the same understanding of the problems and the solutions.

Identifying invalid assumptions about how value is created is essential.
The failures guide the team through a journey toward a good product.
The earlier a failure is, the less costly refining the understanding will be,
and the valuable the learning is for the following activities.

*A collaborative approach to requirements gathering*
A multi-deciplinary team,
a team where each member sees the problems through a different lense,
offers a good ground for the solutions to emerge.

*The existing system is a base of conversation*
“But if Alexander is right, then many of the key characteristics of a
system come from internal forces and not external requirements.“
— Richard Gabriel, Patterns of software

"That is: the product AND its requirements are both being developed
as we try to build the product, and stumble occasionally, and learn."
— Michael Bolton
https://twitter.com/michaelbolton/status/847998544598487041

also this
"Of course, at the beginning of the journey, 
we don't know all the things we need to know! We learn them 
as we develop the product."
— Michael Bolton
https://twitter.com/michaelbolton/status/848003572482682880

The internal forces are the exisiting solutions.

Users learn more about the product as their interactions with it increase.
In an environemnt where feedback is highly valued, 
stakeholders often try the software as it is being developed.
That changes their view as well as their expectations.
Using of the existing system as a reference for conversations,
they can express their problems clearly to the team.

Things change all the time.
Taking a lot of decisions early is rarely beneficical in the long run;
unless for having rich conversations,
these decisions have huge cost and little value;
Indeed, they need to be revsited frequently.
We work toward requirements and we get them when we are done.
Software requirements, like design, are emergent.

We start with assumptions.
We assume that listing the events will help the manager find
and update his target.
But, does that really meet the need of the manager
that wants to update the next event due to a typing issue?
I am not sure of that.
That depends on where the events are found, 
what the managers are really using our system
for, when they do it, and how the software fits in their
lifes.
All of that requires continuous investigation, toughful reflection,
and a lot of trial-and-error.

We work on problems,
and solving a problem changes the setting of the next one.
We approach our problems one by one.
We identify the problem, we assume a solution, we test it, we get feedback,
we learn, and we reflect on our understanding of the problem as well as the
adequacy of the solution.
We repeat this until we come up with a good solution to the right problem.
And only when we end up with proof of viability of a solution
that we take it as a requirement.

Another problem is that identifying the scope of the software early
hinders our ability to learn and inquire deliberately.
The stakehodlers' views change continuously.
They learn more about the solution.
Their interaction with the software gives birth to a set 
of patterns by which they establlsish rules and habits of use.
This invalidates most of our early decisions.
