---
layout: post
comments: true
title:  "Emergent requirements"
date:   2016-12-03 22:27:43 +0100
categories: Software
tags: featured
---

Products thrieve because each helps the user surmount a hindrance or solve a problem.
As a learning activity, product development involves the articulation of a set
of problems and the exploration of a way to solve them.
For the various kinds of software products,
the problems themselves and the context of using the product are not fully known initially.
Identifying them, so, is in itself a complex activity
that requires inquiry, learning, and a reflective mindset.

I will take the requirements, here, as the problems, and the specification as the solutions.

**Failing as a pivot for better decisions**
Software products are different than other kinds of products in that each is unique.
The cost of redistributing a software is low, and often null.
There is a little value in developing something similar to what exists.
We often express the requirements in terms of a solution we already worked on.
We take an other system with and a potentially diferent goal as a reference.
We do this because we are looking for a language.
Each software has its own language that is discoverd iteratively.
Language is more than the words. It is also about the meaning behind the words and their
relationship.

'a quote here'

But, requirements are best expressed in terms the system under development.
Each requirement in terms of the previous requiremenst, or better, the system resulted
from solving the previous problems.
The solution is more than the sum of the requirements.
It entails, too, how these work together and how fit they are within the context of the use.

"Much of the essence of building a program is in fact the debugging of the specification."
- F. Brooks [?]

This suggests that figuring out the requirements before starting the development is based on a set
of assumptions:
 * Each requirement solves a problem the user have.
 * The requirements form a cohesive whole.
 * The requirements, as a whole, 
   improve the life of the user and create less frustration than the problem being addressed.

Identifying invalid assumptions about how value is created is essential.
The failures enlighten the journey toward a fitting product.
The earlier the failure, the less costly refining the understanding will be,
and the valuable the learning will be for the remaining activities.

**A collaborative approach to requirements gathering**

A multi-deciplinary team,
a team where each member sees the problems through a different lense,
offers a good ground for the solutions to emerge.
To have meaningful conversations,
both the team and the user needs to share the same understanding
of the problems and the solutions.
It is a social challenge.

**The existing system is a base of conversation**

By the time the solution becomes usable,
it helps the team have valuable conversations.
It is, then, used as a learning asset and a pivot for the following activities.
In an environment where feedback is highly valued, 
cutomers and stakeholders try the software as it is being developed.
They give feedback from which the team learns and explores improvments
opportunities.
Users learn more about the product as they interact with it.
Using of the existing system as a reference for conversations,
they can express their problems clearly to the team,
and they can reflect on their understanding of their own problems.

Richard Gabriel puuted that well in his book "Patterns of software":

`But if Alexander is right, then many of the key characteristics of a
system come from internal forces and not external requirements.`
— Richard Gabriel, Patterns of software

"That is: the product AND its requirements are both being developed
as we try to build the product, and stumble occasionally, and learn."
— Michael Bolton
https://twitter.com/michaelbolton/status/847998544598487041

also this
"Of course, at the beginning of the journey, 
we don't know all the things we need to know! We learn them 
as we develop the product."
— Michael Bolton
https://twitter.com/michaelbolton/status/848003572482682880

Things change all the time.
Taking a lot of decisions early is rarely beneficical in the long run;
unless for having rich conversations,
these decisions have huge cost and little value;
Indeed, they need to be revsited frequently.
We work toward requirements and we get them when we are done.
Software requirements, like design, are emergent.

We start with assumptions.
We assume that listing the events will help the manager find
and update his target.
But, does that really meet the need of the manager
that wants to update the next event due to a typing issue?
I am not sure of that.
That depends on where the events are found, 
what the managers are really using our system
for, when they do it, and how the software fits in their
lifes.
All of that requires continuous investigation, toughful reflection,
and a lot of trial-and-error.

We work on problems,
and solving a problem changes the setting of the next one.
We approach our problems one by one.
We identify the problem, we assume a solution, we test it, we get feedback,
we learn, and we reflect on our understanding of the problem as well as the
adequacy of the solution.
We repeat this until we come up with a good solution to the right problem.
And only when we end up with proof of viability of a solution
that we take it as a requirement.

Another problem is that identifying the scope of the software early
hinders our ability to learn and inquire deliberately.
The stakehodlers' views change continuously.
They learn more about the solution.
Their interaction with the software gives birth to a set 
of patterns by which they establlsish rules and habits of use.
This invalidates most of our early decisions.

*The software is more than the user interface*
** Software development as automating wireframes**
