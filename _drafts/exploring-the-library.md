Increasing the value for stakeholders is the aim of developing software.
Agile software development is, by itself, a journey of increasing the benefit.
It is about making the most beneficial decisions at the right moment 
while attempting to keep them easy to change in the future.
Decreasing the cost? Not so much. That could be addressed as a side effect
of delivering value continuously and improving the way the work is being done.

I want to talk here a bit about using third-party modules.
Design is the collection of decisions that incorporate the learning of the team.
Each decision imposes new constraints on the system,
and it contributes, directly or indirectly, to the next decisions.
It shapes the structure of the system.
Finally, It introduces a trade-off between implementation and leverage,
or, if I can reframe it better; between the cost of local maintenace 
and the cost of accepting decisions made outside the context of our system.

**The most important kind of resuse in software development**
If programming is learning, and the hardest asset to communicate is
the implicit knowledge acquired through developing the software,
then knowledge resuse is more valuable than code reuse.
Konwledge reuse covers a wide spectrum that ranges from stories and design patterns to frameworks and programming languages.

**The cost of giving up design decisions**
**Expermentation is not descresing code quality, it is about giving up decisions**

What I am not in favour of, is that the choice is based on fashion, or feedback.
By * , we don't simply pick a library or a component or a service and start with. We, bit by bit, discover that the solution we are encovering to the actual problem needs that kind of api.
We refactor, we notice patterns, we realize that the cost of maintaining and growing those parts the system are best handled to a specific third-party component.
Only then, we bring in the component.
The choice is best seen from the lenses of the emergent patterns that will addressed by this component.
I see that the choice of a third-party component should be explained by the emergence of a kind of patterns that prooves out to be best addressed by that component.
The problem arise when we fail to tune a moment when the cost of leverage exceedes the cost of implementation.
We explore and we learn, and we notice patterns, then we design or refactor the software to a design that best accomondates fluency in codifying the learning.

The discovery * will bring with it a whole context of thinking, of old decisions and of learned patterns. This makes the choice focused, limits the options and  gives an accurate context to think about the implementation/leverage trande-off.

Grady Booch once said that 
'There are three kinds of reuse in software ...'.

 and it will * rigid abstractions.
 The cost of leverage consists in giving up some decisions to a third-party authority.
 
 Refactoring 
 
 So the trade-off we face
 
