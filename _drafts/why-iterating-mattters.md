Thinking about software visibility lately, two sayings keep coming to my mind
over and over.
the first was from D. T. Ross, the 1968 NATO conference,
"The most deadly thing in software is the concept,
which almost universally seems to be followed,
that you are going to specify what you are going to do, and then do it.
And that is where most of our troubles come from."
The second originated from Frederick Brooks' classic "No silver bullet",
"The structures of software remain inherently unvisualizable,
thus depriving the mind of some of its most powerful conceptual tools."

An other saying I still remember hearing from Grady Booch.
He said: "When I visit a team, 
I ask them for the patterns of the system they are developing".
Then, I remember the authors of "Documenting software architecture" 
insisting on putting the rational behind each architectural decision explicitly
inside the software architecture documentation.

I still believe that the biggest problem with software is visibility.
How to see the tradeoffs involved in the decisions we need to make?
How can we reason about the current problem?
How to use a model that allows the team to express the relevent parameters?
How to communicate the decisions we have made?
How to ensure the respect of these decisions as the design evolve?

To start, let's keep in mind that "our priority is to satisfy the customer
through delivery of valuable software".
A user interacts with a software through the interface.
The succession of visited views allows for a story to emerge
and bring a meaning more than the sum of views.
Audio user interfaces and VR interfaces gives more options for living the story.

Is a one-view representation an expressive model to think about the user interface?
A software solution is more than the sum of interfaces.
It is the stories of value delivered with each interaction session.
Is a session-based model a good one?
Maybe better than a model based one-view units.
But, how can we model these stories?
How to model and then communicate a story?
By reading it, by telling it in context, by telling it outside context, by playing it.

How can we know we are building a right thing?
We don't know. We assume we are.
At best, a set of static interfaces enables the team to test a part
of the problem.
They fit well with the other parts?
The interactions as a whole make sense to the user?
How the user will use the software in the real world? and when?
We, then, use the emerge feedback of these answers to adapt the product.

There is a lot of situations in software development where the code view is limiting.
The tactic knowledge also is misleading due to the faced complexity,
the software size, and the rate of change.

Conversation and frequent participation between the team members
and the user helps here.
BUt, How visualtion helps here?

I believe that the consistency of design decisions
is more important than a good application of sound design principles.

UML, wireframes, and a consistent language,
each frees us from a set of constraints and enables us to express
the set of forces in that view.
But, the software is more than the sum of its views.
The interactions between the views matter.
When we design to a specified view, we optimize for it, and we
will make decisions that could be significant in the other views of the system.
More dangerous this will be when the view is not the user
view or the business view.

The problem is not with UML itself.
It is with the illusion that UML have a one-to-one mapping to the code.

When I hear "The software has a database model, a domain model, and a user
interface model are highly correlated", I often hear
"I optimized for three different and got the same units".
And even if the result is unavoidable in the moment,
is the separation worthwhile?
