---
layout: post
comments: true
title:  "Emergent requirements"
date:   2016-12-03 22:27:43 +0100
categories: Software
tags: featured
---

Product development is a journey of collaborative learning.
We learn how to solve effectively an unknown set of problems.
This is hardly a linear process.
It, often, entails iterations, rework, and removal of completed functionalities
entirely from the product.
The aim, thus, is to unconver misunderstanding
and to identify the critical aspects of each faced problem.
Early failures help the team find its way toward a good product.
And so, identifying invalid assumptions about how value is created 
deserves a deep consideration in all the activities of the development process.

To close the metaphor loop, here, we could say that the requirements 
constitute the way to a good product.
Users use a product because it solves their problems in a way that fits
well within their contexts.
They see solutions, not features.
And they learn more about the product as their interactions with it increase.

In an environemnt where feedback is highly valued, 
stakeholders often try the software as it is being developed.
That changes their view as well as their expectations.
Using of the existing system as a reference for conversations,
they can express their problems clearly to the team.

Things change all the time.
Taking a lot of decisions early is rarely beneficical in the long run;
unless for having rich conversations,
these decisions have huge cost and little value;
Indeed, they need to be revsited frequently.
We work toward requirements and we get them when we are done.
Software requirements, like design, are emergent.

We start with assumptions.
We assume that listing the events will help the manager find
and update his target.
But, does that really meet the need of the manager
that wants to update the next event due to a typing issue?
I am not sure of that.
That depends on where the events are found, 
what the managers are really using our system
for, when they do it, and how the software fits in their
lifes.
All of that requires continuous investigation, toughful reflection,
and a lot of trial-and-error.

We work on problems,
and solving a problem changes the setting of the next one.
We approach our problems one by one.
We identify the problem, we assume a solution, we test it, we get feedback,
we learn, and we reflect on our understanding of the problem as well as the
adequacy of the solution.
We repeat this until we come up with a good solution to the right problem.
And only when we end up with proof of viability of a solution
that we take it as a requirement.

Another problem is that identifying the scope of the software early
hinders our ability to learn and inquire deliberately.
The stakehodlers' views change continuously.
They learn more about the solution.
Their interaction with the software gives birth to a set 
of patterns by which they establlsish rules and habits of use.
This invalidates most of our early decisions.
