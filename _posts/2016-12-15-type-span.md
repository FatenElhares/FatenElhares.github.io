---
layout: post
title:  "Type span"
date:   2016-12-15 11:49:00 +0100
categories: Software, Naming
tags: featured
---

It is a wise decision to avoid using boolean variables within the boudaries of a module.
The boolean type offers weak semantics and it does not convey much information about 
the context of its evalution.
This is often labeled "boolean blindness".
Type span, also, omits knowledge about the evaluation context,
not by deminishing the number of possible states,
but by making a larger number of states possible.
Yes, that's it, it makes impossible states possible.

The evaluation context carries semantics and constraints about the evaluated variable.
These information are lost when they are not conveyed in the type.
Indeed, it is very hard to keep that implicit knowledge in mind
due the large set of assumptions that could made
and the growing complexity of the program itself.

Type span involves a wider range of types.
An even number, for example, can be modeled as an integer. We could have:

```
Integer two  = new Integer(2);
Integer four = new Integer(4);
```

When we use those variables, we will not have a guarentee
that either of them is an even number.
The signature of the client will be like this:

```
accept(Integer anEvenNumber)
```

There is a waste of knowledge.
That turns out to be a source of bugs as the signature of the client
goes to higher abstract forms, especially when there is not enough test
coverage in the system to cover the the situations that involves the inital assignment.

It would be better to name it "anEvenNumber".
Except  that the name of the argument is better to be focused on the role the argument
plays in the body of the procedure, and not its nature.
Mixing the role and the type of the arguemnt in the name won't
make the code easy to understand.
I see it as a subtle form of the hungarian notation.

Let's think now about modeling even numbers this way:

```
EvenNumber two  = new EvenNumber(1);
EvenNumber four = new EvenNumber(2);
```

The "accept" procedure will be:

```
accept(EvenNumber itsRole)
```

And now, the context of the initial computation of the numbers may not be wholly required.
The required aspect of it, that of the nature of two and four is well communicated.
And, yes, you could just use EvenNumber as a wrapper, like this:

```
EvenNumber two  = new EvenNumber(2);
EvenNumber four = new EvenNumber(4);
```

But, here, we have an implicit duplication in the nature of the argument.
But, as always, it is a trade-off where the use of the structure influences its internal
implementation, wich itself changes as the software grows.
