---
layout: post
title:  "Type span"
date:   2016-12-15 11:49:00 +0100
categories: Software, Naming
tags: featured
---

It is a wise decision to avoid using boolean variables within a module boudaries.
If we measure the quality of the message by the amount of information being transferred,
then the boolean type does not help us communicate well.

The boolean type provides two states.
When used alone, it hides the context of its evaluation.
This is often labeled "boolean blindness".
A boolean message is a good information carrier between independent modules.
In such situations, we work toward decreasing coupling and hiding decisions from collaborators.

But, that should not go so far.
Type span is the opposite situation of boolean blindness.
It omits knowledge about the evaluation, not by deminishing the number of possible states,
but by making a larger number of states possible.
Instead of boolean, we can consider wider range of types; like integer and string.
Each one of those types models the result of an opertion 
and not much the constraints applied within context of its evaulation.
It is impossible, thus, to recover the constraints guarenteed by the evaluation context.

An even number, for example, can be modeled as a mere integer. We could have:

```
Integer two  = new Integer(2);
Integer four = new Integer(4);
```

When we use those variables, we will not have a guarentee
that either of them is an even number.
The signature of the client will be like this:

```
accept(Integer anEvenNumber)
```

There is a waste of knowledge.
That turns out to be a source of bugs as the signature of the client
goes to higher abstract forms, especially when there is not enough test
coverage in the system to cover the the situations that involves the inital assignment.

It would be better to name it "anEvenNumber".
Except  that the name of the argument is better to be focused on the role the argument
plays in the body of the procedure, and not its nature.
Mixing the role and the type of the arguemnt in the name won't
make the code easy to understand.
I see it as a subtle form of the hungarian notation.

Let's think now about modeling even numbers this way:

```
EvenNumber two  = new EvenNumber(1);
EvenNumber four = new EvenNumber(2);
```

The "accept" procedure will be:

```
accept(EvenNumber itsRole)
```

And now, the context of the initial computation of the numbers may not be wholly required.
The required aspect of it, that of the nature of two and four is well communicated.
And, yes, you could just use EvenNumber as a wrapper, like this:

```
EvenNumber two  = new EvenNumber(2);
EvenNumber four = new EvenNumber(4);
```

But, here, we have an implicit duplication in the nature of the argument.
But, as always, it is a trade-off where the use of the structure influences its internal
implementation, wich itself changes as the software grows.
