---
layout: post
comments: true
title:  "On typing"
date:   2016-12-31 23:23:30 +0100
categories: Software
tags: typing
---

I am learning touch typing for quite a while now, mainly because it is
fun. Typing that fast, that illusionary control, isn't that astonishing?
It is a valuable endeavor.
Indeed, my workflow has been improving since I became a faster typist.

Typing can be seen a tool.
We use it to move words and expressions in our minds to the computer.
A good tool is often invisible, a part of its user, and so is typing.
If typing does not require a dedicate amount of mental energy, 
then adding, editing, and deleting text become much easier and less costly.
That helped me to cultivate habbits 
such as daily writing and real-time thoughts documentation.

Another thing I learned from touch typing is how 'Less is more' works in the real world.
The less I focus on speed and put more effort on pressing the right keys, the faster I am.
This translates very well to the world of programming and design decisions.
The faster I rush and make a decision, the more it turns out to be a bad fit.

Most of the time of the programmer is spent thinking.
I type far less code as I gain more experience and I learn new things
, and some of the most shining programmers I know are not touch typists. 
Meanwhile, typing fast is good for experimentation.
My mind is often fooled by false symmetries and confirmation bias.
This becomes obvious when I work on subtle abstractions or new code bases,
which is most of time by the way.
I often find aspects of the existing code that I have missed only late;
after I make a series of decisions.
But, when I work through tiny increments and I translate my thinking to a test ealy,
that class of mistakes fades away.
I am able to spot those fallacies early that way.
I use the written test, also, to judge the fitness of the next knowledge within
the existing code.
It is not unusual for me to rewrite or to remove the last lines of code I write,
that it valuable because, that way, I dismiss the assumptions behind that code 
and I learn what could be a good fit for the situation.
That could be done in mind sometimes,
but, for complex situations or for legacy code bases, it is easy to be fooled by complexity.
